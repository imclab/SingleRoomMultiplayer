<html>
	<head>

		<title>Typed Vector Pool</title>

	</head>

	<body>

		<script type="text/javascript">

			function TypedPool( size, length ) {
				this.size = size;
				this.length = length;

				var memory = new Float64Array( size * length ),
					index = -1,
					released = [];

				this.get = function() {
					++index;

					if( index < this.length ) {
						return index;
					}
					else if( index === this.length-1 && released.length ) {
						return released.pop();
					}
					else {
						throw new Error('Pool ran out');
					}
				};

				this.release = function( i ) {
					this.reset();
					this.released.push( i );
				};

				this.reset = function( i ) {
					var j = 3;

					i = i * 3;

					while( --j >= 0 ) {
						memory[ i + j ] = 0;
					}
				};


				this.getMemory = function() {
					return memory;
				};


				this.getX = function( i ) {
					return memory[ i * 3 ];
				};
				this.getY = function( i ) {
					return memory[ i * 3 + 1 ];
				};
				this.getZ = function( i ) {
					return memory[ i * 3 + 2 ];
				};

				this.setX = function( i, val ) {
					memory[ i * 3 ] = val;
				};
				this.setY = function( i, val ) {
					memory[ i * 3 + 1 ] = val;
				};
				this.setZ = function( i, val ) {
					memory[ i * 3 + 1] = val;
				};


				this.set = function( i, x, y, z ) {
					i *= 3;
					memory[ i ] = x;
					memory[ i + 1 ] = y;
					memory[ i + 2 ] = z;
				};


				this.getComponent = function( i, index ) {
					if(index < this.size) {
						return memory[ i * 3 + index ];
					}
					else {
						throw new Error( 'Index out of range: ' + index );
					}
				};

				this.copy = function( i, source ) {
					i *= 3;
					source *= 3;

					memory[ i ]     = memory[ source ];
					memory[ i + 1 ] = memory[ source + 1 ];
					memory[ i + 2 ] = memory[ source + 2 ];
				};


				this.add = function( i, source ) {
					i *= 3;
					source *= 3;

					memory[ i ]     += memory[ source ];
					memory[ i + 1 ] += memory[ source + 1 ];
					memory[ i + 2 ] += memory[ source + 2 ];
				};

				this.addScalar = function( i, s ) {
					i *= 3;

					memory[ i ]     += s
					memory[ i + 1 ] += s;
					memory[ i + 2 ] += s;
				};

				this.addVectors = function( i, a, b ) {
					i *= 3;
					a *= 3;
					b *= 3;

					memory[ i ]     = memory[ a ]     + memory[ b ];
					memory[ i + 1 ] = memory[ a + 1 ] + memory[ b + 1 ];
					memory[ i + 2 ] = memory[ a + 2 ] + memory[ b + 2 ];
				};


				this.sub = function( i, source ) {
					i *= 3;
					source *= 3;

					memory[ i ]     -= memory[ source ];
					memory[ i + 1 ] -= memory[ source + 1 ];
					memory[ i + 2 ] -= memory[ source + 2 ];
				};

				this.subVectors = function( i, a, b ) {
					i *= 3;
					a *= 3;
					b *= 3;

					memory[ i ]     = memory[ a ]     - memory[ b ];
					memory[ i + 1 ] = memory[ a + 1 ] - memory[ b + 1 ];
					memory[ i + 2 ] = memory[ a + 2 ] - memory[ b + 2 ];
				};


				this.multiply = function( i, source ) {
					i *= 3;
					source *= 3;

					memory[ i ]     *= memory[ source ];
					memory[ i + 1 ] *= memory[ source + 1 ];
					memory[ i + 2 ] *= memory[ source + 2 ];
				};

				this.multiplyScalar = function( i, s ) {
					i *= 3;

					memory[ i ]     *= s
					memory[ i + 1 ] *= s;
					memory[ i + 2 ] *= s;
				};

				this.multiplyVectors = function( i, a, b ) {
					i *= 3;
					a *= 3;
					b *= 3;

					memory[ i ]     = memory[ a ]     * memory[ b ];
					memory[ i + 1 ] = memory[ a + 1 ] * memory[ b + 1 ];
					memory[ i + 2 ] = memory[ a + 2 ] * memory[ b + 2 ];
				};



				this.applyMatrix3 = function( i, m ) {
					i *= 3;

					var x = memory[i], y = memory[i+1], z = memory[i+2],
						e = m.elements;

					memory[ i ]     = e[0] * x + e[3] * y + e[6] * z;
					memory[ i + 1 ] = e[1] * x + e[4] * y + e[7] * z;
					memory[ i + 2 ] = e[2] * x + e[5] * y + e[8] * z;
				};

				this.applyMatrix4 = function( i, m ) {
					i *= 3;

					var x = memory[i], y = memory[i+1], z = memory[i+2],
						e = m.elements;

					memory[ i ]     = e[0] * x + e[4] * y + e[8]  * z + e[12];
					memory[ i + 1 ] = e[1] * x + e[5] * y + e[9]  * z + e[13];
					memory[ i + 2 ] = e[2] * x + e[6] * y + e[10] * z + e[14];
				};

				this.applyProjection = function( i, m ) {
					i *= 3;

					var x = memory[ i ];
					var y = memory[ i + 1 ];
					var z = memory[ i + 2 ];

					var e = m.elements;
					var d = 1 / ( e[3] * x + e[7] * y + e[11] * z + e[15] ); // perspective divide

					memory[ i ]     = ( e[0] * x + e[4] * y + e[8]  * z + e[12] ) * d;
					memory[ i + 1 ] = ( e[1] * x + e[5] * y + e[9]  * z + e[13] ) * d;
					memory[ i + 2 ] = ( e[2] * x + e[6] * y + e[10] * z + e[14] ) * d;
				};

				this.applyQuaternion = function( i, q ) {
					var x = memory[ i ]    ;
					var y = memory[ i + 1 ];
					var z = memory[ i + 2 ];

					var qx = q.x;
					var qy = q.y;
					var qz = q.z;
					var qw = q.w;

					// calculate quat * vector
					var ix =  qw * x + qy * z - qz * y;
					var iy =  qw * y + qz * x - qx * z;
					var iz =  qw * z + qx * y - qy * x;
					var iw = -qx * x - qy * y - qz * z;

					// calculate result * inverse quat
					memory[ i ]     = ix * qw + iw * -qx + iy * -qz - iz * -qy;
					memory[ i + 1 ] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
					memory[ i + 2 ] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
				};

				this.transformDirection = function( i, m ) {
					var x = memory[ i ]    ;
					var y = memory[ i + 1 ];
					var z = memory[ i + 2 ];

					var e = m.elements;

					memory[ i ]     = e[0] * x + e[4] * y + e[8]  * z;
					memory[ i + 1 ] = e[1] * x + e[5] * y + e[9]  * z;
					memory[ i + 2 ] = e[2] * x + e[6] * y + e[10] * z;

					this.normalize();
				};


				this.divide = function( i, source ) {
					i *= 3;
					source *= 3;

					memory[ i ]     /= memory[ source ];
					memory[ i + 1 ] /= memory[ source + 1 ];
					memory[ i + 2 ] /= memory[ source + 2 ];
				};

				this.divideScalar = function( i, s ) {
					i *= 3;

					if ( s !== 0 ) {
						memory[ i ]     /= s;
						memory[ i + 1 ] /= s;
						memory[ i + 2 ] /= s;
					}
					else {
						memory[ i ]     = 0;
						memory[ i + 1 ] = 0;
						memory[ i + 2 ] = 0;
					}
				};


				this.min = function( i, s ) {
					i *= 3;
					s *= 3;

					var vx = memory[s + 0],
						vy = memory[s + 1],
						vz = memory[s + 2];

					if ( memory[i] > vx ) {
						memory[i] =  vx;
					}

					if ( memory[i + 1] > vy ) {
						memory[i + 1] =  vy;
					}

					if ( memory[i + 2] > vz ) {
						memory[i + 2] =  vz;
					}
				};

				this.max = function( i, s ) {
					i *= 3;
					s *= 3;

					var vx = memory[s + 0],
						vy = memory[s + 1],
						vz = memory[s + 2];

					if ( memory[i] < vx ) {
						memory[i] = vx;
					}

					if ( memory[i + 1] < vy ) {
						memory[i + 1] = vy;
					}

					if ( memory[i + 2] < vz ) {
						memory[i + 2] = vz;
					}
				};

				this.clamp = function( i, min, max ) {

					i *= 3;
					min *= 3;
					max *= 3;

					var minX = memory[ min + 0 ],
						minY = memory[ min + 1 ],
						minZ = memory[ min + 2 ],
						maxX = memory[ max + 0],
						maxY = memory[ max + 1],
						maxZ = memory[ max + 2],
						x = memory[ i + 0 ],
						y = memory[ i + 1 ],
						z = memory[ i + 2 ];

					// This function assumes min < max, if this assumption isn't true it will not operate correctly

					if ( x < minX ) {
						memory[ i + 0 ] = minX;

					}
					else if ( x > maxX ) {
						memory[ i + 0 ] = maxX;
					}

					if ( y < minY ) {
						memory[ i + 1 ] = minY;
					}
					else if ( y > maxY ) {
						memory[ i + 1 ] = maxY;
					}

					if ( z < minZ ) {
						memory[ i + 2 ] = minZ;
					}
					else if ( z > maxZ ) {
						memory[ i + 2 ] = maxZ;
					}
				};

			}








			var size = 4096;
			var vec3Pool = new TypedPool( 3, size );


			var start = Date.now();


			for( var j = 0; j < size; ++j ) {
				var vec = vec3Pool.get();

				vec3Pool.addScalar( vec, j+1 );
			}

			console.log( Date.now() - start, vec3Pool.getMemory() );

		</script>

	</body>
</html>